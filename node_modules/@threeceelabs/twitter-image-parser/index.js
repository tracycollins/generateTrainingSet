/*jslint node: true */
"use strict";

/* TWITTER IMAGE PARSER */
/* tweet-image-parser */

const vision = require("@google-cloud/vision");
const visionClient = new vision.ImageAnnotatorClient();

const async = require("async");
const debug = require("debug")("tip");
const keywordExtractor = require("keyword-extractor");

const wordExtractionOptions = {
  language:"english",
  remove_digits: true,
  return_changed_case: true,
  remove_duplicates: true
};

const chalk = require("chalk");
const chalkError = chalk.bold.red;
const chalkAlert = chalk.red;
const chalkWarn = chalk.red;
const chalkLog = chalk.gray;
const chalkInfo = chalk.black;

let histograms = {};
histograms.images = {};

const jsonPrint = function (obj){
  if (obj) {
    return JSON.stringify(obj, null, 2);
  }
  else {
    return "UNDEFINED";
  }
};

exports.clearGlobalHistograms = function (){
  histograms.images = {};
};

exports.getGlobalHistograms = function (callback){
  callback(histograms);
};

function textDetection(params, callback){

  const options = params.options;
  const imageUri = params.imageUri;

  let userHistograms = {};
  userHistograms.images = {};

  visionClient.documentTextDetection(imageUri)
  .then(function(response) {

    const texts = response[0].textAnnotations;

    debug(chalkLog("IMAGE PARSE RESPONSE | TEXT"
      + " | @" + options.screenName
      + " | " + imageUri
      + " | TEXTS: " + texts.length
    ));

    if (texts.length === 0){
      return(callback(null, userHistograms));
    }

    async.eachSeries(texts, function(textObj, cb0){

      const description = textObj.description;

      const wordArray = keywordExtractor.extract(description, wordExtractionOptions);

      debug(chalkAlert("->- IMAGE TEXT ITEM"
        + "\ndescription\n" + jsonPrint(description)
        + "\nwordArray\n" + jsonPrint(wordArray)
      ));


      async.each(wordArray, function(word, cb1){

        const wordLowerCase = word.toLowerCase();
        const wordTrim = wordLowerCase.trim();
        const item = wordTrim.replace(/\$/gi, "dollar_sign");  // Mongo doesn't like $ 

        if (histograms.images[item] === undefined) {
          histograms.images[item] = {};
          histograms.images[item].total = 0;
          histograms.images[item].left = 0;
          histograms.images[item].neutral = 0;
          histograms.images[item].right = 0;
          histograms.images[item].positive = 0;
          histograms.images[item].negative = 0;
          histograms.images[item].uncategorized = 0;
        }

        if (options.updateGlobalHistograms) {

          histograms.images[item].total += 1;

          if (options.category) {
            if (options.category === "left") { histograms.images[item].left += 1; }
            if (options.category === "neutral") { histograms.images[item].neutral += 1; }
            if (options.category === "right") { histograms.images[item].right += 1; }
            if (options.category === "positive") { histograms.images[item].positive += 1; }
            if (options.category === "negative") { histograms.images[item].negative += 1; }
          }
          else {
            histograms.images[item].uncategorized += 1;
          }
        }

        userHistograms.images[item] = (userHistograms.images[item] === undefined) ? 1 
          : userHistograms.images[item]+1;

        debug(chalkAlert("->- IMAGE Es"
          + " | " + userHistograms.images[item]
          + " | " + item
        ));

        async.setImmediate(function() { cb1(); });

      }, function(err){
        async.setImmediate(function() { cb0(); });
      });

    }, function(){
      callback(null, userHistograms);
    });

    // let description = "";

    // async.eachSeries(texts, function(text, cb){

    //   description = description + " " + text.description;

    //   debug(chalkAlert("->- IMAGE TEXT Es"
    //     + " | " + text.description
    //   ));

    //   cb();

    // }, function(){

    //   callback(null, description);

    // });

  })
  .catch(function(err){
    if (err.code === 8) {
      console.log(chalkError("*** VISION TEXT DETECTION QUOTA ERROR | CODE: " + err.code));
    }
    else if (err.code === 7) {
      console.log(chalkError("*** VISION TEXT DETECTION CLOUD VISION API ERROR"
        + " | CODE: " + err.code
        + " | DETAILS: " + err.details
      ));
    }
    else {
      console.log(chalkError("*** VISION TEXT DETECTION ERROR"
        + "\n" + jsonPrint(err)
      ));
    }
    callback(err, imageUri);
  });
}

function labelDetection(params, callback){

  const options = params.options;
  const imageUri = params.imageUri;
  // const inputHistogram = params.histogram;

  let userHistograms = {};
  userHistograms = params.histogram;

  if (userHistograms.images === undefined) { userHistograms.images = {}; }

  visionClient.labelDetection(imageUri)
  .then(function(response) {
    const labels = response[0].labelAnnotations;
    debug(chalkLog("IMAGE PARSE RESPONSE | LABELS"
      + " | @" + options.screenName
      + " | " + imageUri
      + " | LABELS: " + labels.length
    ));

    if (labels.length === 0){
      return(callback(null, userHistograms));
    }

    async.each(labels, function(label, cb){

      let description = label.description;

      if (histograms.images[description] === undefined) {
        histograms.images[description] = {};
        histograms.images[description].total = 0;
        histograms.images[description].left = 0;
        histograms.images[description].neutral = 0;
        histograms.images[description].right = 0;
        histograms.images[description].positive = 0;
        histograms.images[description].negative = 0;
        histograms.images[description].uncategorized = 0;
      }

      if (options.updateGlobalHistograms) {

        histograms.images[description].total += 1;

        if (options.category) {
          if (options.category === "left") { histograms.images[description].left += 1; }
          if (options.category === "neutral") { histograms.images[description].neutral += 1; }
          if (options.category === "right") { histograms.images[description].right += 1; }
          if (options.category === "positive") { histograms.images[description].positive += 1; }
          if (options.category === "negative") { histograms.images[description].negative += 1; }
        }
        else {
          histograms.images[description].uncategorized += 1;
        }

      }

      userHistograms.images[description] = (userHistograms.images[description] === undefined) ? 1 
        : userHistograms.images[description]+1;

      debug(chalkAlert("->- IMAGE Es"
        + " | " + userHistograms.images[description]
        + " | " + description
      ));

      async.setImmediate(function() { cb(); });

    }, function(){
      callback(null, userHistograms);
    });

  })
  .catch(function(err){
    console.log(chalkError("*** VISION LABEL DETECTION ERROR | " + err));
    console.log(chalkError("*** VISION LABEL DETECTION ERROR | " + jsonPrint(err)));
    console.trace(chalkError(err));
    callback(err, imageUri);
  });
}

exports.parseImage = function (imageUri, options, callback){

  debug(chalk.blue("\nPARSE IMAGE URI: " + imageUri + "\n"));

  if (imageUri === "undefined") {
    console.error(chalkError("*** PARSER IMAGE URI UNDEFINED"));
    return(callback("PARSER IMAGE URI UNDEFINED", imageUri));
  }

  async.waterfall([

    function(cb){
      textDetection({ imageUri: imageUri, options: options}, function(err, textHistogram){
        cb(err, textHistogram);
      });
    },
    function(textHistogram, cb){
      labelDetection({ imageUri: imageUri, options: options, histogram: textHistogram}, function(err, histogram){
        cb(err, histogram);
      });
    }

  ], function(err, histogram){

    debug(chalkAlert("PARSE IMAGE HISTORAM\n" + jsonPrint(histogram)));

    callback(err, histogram);
  });

};
