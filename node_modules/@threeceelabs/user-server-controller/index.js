/*jslint node: true */
/*jshint sub:true*/
"use strict";

const twitterDateFormat = "ddd MMM DD HH:mm:ss Z YYYY"; // Wed Aug 27 13:08:45 +0000 2008
const compactDateTimeFormat = "YYYYMMDD HHmmss";

const MIN_FOLLOWER_COUNT = process.env.WA_MIN_FOLLOWERS || 5000;
const DEFAULT_CURSOR_BATCH_SIZE = process.env.DEFAULT_CURSOR_BATCH_SIZE || 100;

console.log("USC | MIN_FOLLOWER_COUNT: " + MIN_FOLLOWER_COUNT);

const async = require("async");
const treeify = require("treeify");
const deepcopy = require("deepcopy");
const debug = require("debug")("user");
const defaults = require("object.defaults/immutable");
const util = require("util");
const EventEmitter = require("events").EventEmitter;

const chalk = require("chalk");
const chalkInfo = chalk.black;
const chalkLog = chalk.gray;
const chalkAlert = chalk.red;
const chalkError = chalk.bold.red;

const moment = require("moment");
const mongoose = require("mongoose");

let dbReadyState = "INIT";

switch (global.dbConnection.readyState) {
	case 0:
		dbReadyState = "DISCONNECTED";
	break;
	case 1:
		dbReadyState = "CONNECTED";
	break;
	case 2:
		dbReadyState = "CONNECTING";
	break;
	case 3:
		dbReadyState = "DISCONNECTING";
	break;
}

console.log(chalkInfo("USC | DB READY STATE: " + dbReadyState));

const userModel = require("@threeceelabs/mongoose-twitter/models/user.server.model");
const User = global.dbConnection.model("User", userModel.UserSchema);

const DEFAULT_INPUT_TYPES = [
	"emoji",
	"hashtags",
	"images",
	"mentions",
	"urls",
	"words"
];

function msToTime(d) {
  const duration = parseInt(d);
  let seconds = parseInt((duration / 1000) % 60);
  let minutes = parseInt((duration / (1000 * 60)) % 60);
  let hours = parseInt((duration / (1000 * 60 * 60)) % 24);
  let days = parseInt(duration / (1000 * 60 * 60 * 24));
  days = (days < 10) ? "0" + days : days;
  hours = (hours < 10) ? "0" + hours : hours;
  minutes = (minutes < 10) ? "0" + minutes : minutes;
  seconds = (seconds < 10) ? "0" + seconds : seconds;
  return days + ":" + hours + ":" + minutes + ":" + seconds;
}

const jsonPrint = function (obj){
  if (obj) {
    return treeify.asTree(obj, true, true);
  }
  else {
    return "UNDEFINED";
  }
};

function printCat(c){
  if (c === "left") { return "L"; }
  if (c === "neutral") { return "N"; }
  if (c === "right") { return "R"; }
  if (c === "positive") { return "+"; }
  if (c === "negative") { return "-"; }
  if (c === "none") { return "0"; }
  return ".";
}


let totalUsers = 0;

const UserServerController = function(appname){

	console.log("USER SERVER CONTROLLER | APP NAME: " + appname);

	this.appname = appname;

	User.countDocuments({}, function(err, count){
		totalUsers = count;
		console.log(chalkInfo("USC | " + totalUsers + " USERS IN DB"));
	});

	let self = this;

  self.emit("ready", appname);
};

util.inherits(UserServerController, EventEmitter);

let maxInputsHashMap = {};

UserServerController.prototype.resetMaxInputsHashMap = function () {
	maxInputsHashMap = {};
};

UserServerController.prototype.getMaxInputsHashMap = function () {
	return maxInputsHashMap;
};

UserServerController.prototype.findOneUserPromise = function (params) {
	return new Promise(function(resolve, reject) {
		UserServerController.prototype.findOneUser(params.user, {noInc: params.nodeInc}, function(err, user){
			if (err) {
				reject(err);
			}
			else {
				resolve(user);
			}
		});
	});
};

UserServerController.prototype.findOneUser = function (user, params, callback) {

	if (!user.nodeId || (user.nodeId === undefined)){
		return(callback("userServerController: findOneUser: USER ID UNDEFINED", user));
	}

	if (!user.screenName || (user.screenName === undefined)){
		return(callback("userServerController: findOneUser: USER SCREEN NAME UNDEFINED", user));
	}

	const query = { nodeId: user.nodeId };

	if (params.lean === undefined) { params.lean = true; }
	if (params.upsert === undefined) { params.upsert = true; }

	let update = { 
		"$set": { 
			nodeType: "user",
			entities: user.entities,
			isTwitterUser: true,
			screenName: user.screenName.toLowerCase(),
			screenNameLower: user.screenName.toLowerCase(),
			url: user.url,
			profileUrl: user.profileUrl,
			profileImageUrl: user.profileImageUrl,
			verified: user.verified,
			isTopTerm: user.isTopTerm
		}
	};

	if (user.userId !== undefined) { 
		update["$set"].userId = user.userId;
	}
	else {
		update["$set"].userId = user.nodeId;
	}

	if ((user.createdAt !== undefined) && user.createdAt) { 
		update["$set"].createdAt = user.createdAt;
	}

	if ((user.lastSeen !== undefined) && user.lastSeen && user.updateLastSeen) { 
		update["$set"].lastSeen = user.lastSeen;
	}
	else if (user.updateLastSeen){
		update["$set"].lastSeen = Date.now();
	}

	if ((user.category !== undefined) && user.category) { 
		update["$set"].category = user.category;
	}

	if ((user.categoryAuto !== undefined) && user.categoryAuto) { 
		update["$set"].categoryAuto = user.categoryAuto;
	}

	if (params.setMentions) { 
		update["$set"].mentions = user.mentions;
	}
	else if (!params.noInc) { 
		update["$inc"] = {};
		update["$inc"].mentions = 1;
	}

	if (user.lastTweetId !== undefined){
		update["$set"].lastTweetId = user.lastTweetId;
	}

	if (user.following !== undefined){
		update["$set"].following = user.following;
	}

	if (user.threeceeFollowing !== undefined){
		update["$set"].threeceeFollowing = user.threeceeFollowing;
	}

	if (user.name !== undefined){
		update["$set"].name = user.name;
	}

	if ((user.previousName !== undefined) && user.previousName) { 
		update["$set"].previousName = user.previousName;
	}

	if (user.description !== undefined){
		update["$set"].description = user.description;
	}

	if ((user.previousDescription !== undefined) && user.previousDescription) { 
		update["$set"].previousDescription = user.previousDescription;
	}

	if (user.statusId !== undefined){
		update["$set"].statusId = user.statusId;
	}

	if (user.previousStatusId !== undefined){
		update["$set"].previousStatusId = user.previousStatusId;
	}

	if (user.status !== undefined){
		update["$set"].status = user.status;
	}

	if (user.bannerImageAnalyzed !== undefined){
		update["$set"].bannerImageAnalyzed = user.bannerImageAnalyzed;
	}
	if (user.bannerImageUrl !== undefined){
		update["$set"].bannerImageUrl = user.bannerImageUrl;
	}

	if (user.languageAnalyzed !== undefined){
		update["$set"].languageAnalyzed = user.languageAnalyzed;
	}
	if (user.languageAnalysis !== undefined){
		update["$set"].languageAnalysis = user.languageAnalysis;
	}
	
	if (user.histograms && (Object.keys(user.histograms).length > 0)){
		update["$set"].histograms = user.histograms;
	}

	if ((user.lastHistogramTweetId !== undefined) && user.lastHistogramTweetId) { 
		update["$set"].lastHistogramTweetId = user.lastHistogramTweetId;
	}

	if ((user.statusesCount !== undefined) && (user.statusesCount > 0)){
		debug("## UPDATE statusesCount"
			+ " | " + user.screenName
			+ " | " + user.statusesCount
		);
		update["$set"].statusesCount = user.statusesCount;
	}
	if ((user.followersCount !== undefined) && (user.followersCount > 0)){
		update["$set"].followersCount = user.followersCount;
	}
	if ((user.friendsCount !== undefined) && (user.friendsCount > 0)){
		update["$set"].friendsCount = user.friendsCount;
	}

	if (user.friends && (user.friends.length > 0)) {
		update["$addToSet"] = {};
		update["$addToSet"].friends = user.friends;
	}
		
	if ((user.rate !== undefined) && (user.rate > 0)){
		update["$set"].rate = user.rate;
	}

	const options = {
		fields: params.fields,
		upsert: params.upsert,
		lean: params.lean,
		setDefaultsOnInsert: true,
		new: true
	};

	User.findOneAndUpdate(
		query,
		update,
		options,
		function(err, us) {
			if (err) {
				if (err.code === 11000) {
					User.remove({nodeId: user.nodeId}, function(err){
						if (err) {
							console.log("REMOVED DUPLICATE USER ERROR " + err + "\n" + user.nodeId);
						}
						else {
							console.log("REMOVED DUPLICATE USER " + user.nodeId);
						}
					});
				}
				else {
					console.log(moment().format(compactDateTimeFormat) 
						+ "\n\n***** USER FINDONE ERROR: USER ID: " + user.nodeId 
						+ "\n" + err
					);
				}
				callback(err, user);
			}
			else {
				
				debug("USR>DB"
					+ " | " + us.nodeId 
					+ " | @" + us.screenName
					+ " | " + us.name
					+ " | Ts " + us.statusesCount 
					+ " | FLs " + us.followersCount 
					+ " | FRs " + us.friendsCount 
					+ " | Ms " + us.mentions 
					+ " | LA " + us.languageAnalyzed 
					+ " | LS " + moment(new Date(us.lastSeen)).format(compactDateTimeFormat) 
				);

				if (us.screenName.toLowerCase() !== us.screenNameLower) {
					console.error(chalkError("*** SCREEN NAME !== SCREEN NAME LOWER"
						+ " | SN @" + us.screenName
						+ " | SNL @" + us.screenNameLower
					));
					return(callback("SCREEN NAME !== SCREEN NAME LOWER", us));
				}

				const mentionsString = (us.mentions !== undefined) ? us.mentions.toString() : "0" ;
				us.mentions = mentionsString ;
				callback(null, us);
			}
		}
	);
};

UserServerController.prototype.findUsersCursor = function (params, callback) {

	let query = (params.query !== undefined) ? params.query : {};
	const batchSizeParam = (params.batchSize !== undefined) ? params.batchSize : DEFAULT_CURSOR_BATCH_SIZE;

	const cursor = User.find(query).cursor({ batchSize: batchSizeParam });

	cursor.on("data", function(user) {
		console.log(chalkInfo("U"
			+ " | @" + user.screenName
			+ " | " + user.nodeId
		));

	});

	cursor.on("end", function() {
		callback(null, null);
	});

	cursor.on("error", function(err) {
		console.error(chalkError("*** ERROR findUsersCursor: " + err));
		callback(err, null);
	});

	cursor.on("close", function() {
		callback(null, null);
	});
};

UserServerController.prototype.convertClassifiedUsersCursor = function (params, callback) {

	debug(chalkInfo("convertClassifiedUsersCursor"));

	const searchKey = "keywords";

	const batchSizeParam = (params.batchSize !== undefined) ? params.batchSize : DEFAULT_CURSOR_BATCH_SIZE;

	let query = {};
	query[searchKey] = { "$nin": [ false, "false", null, {}, undefined ] };

	let classifiedUsersObj = {};
	let classifiedUsersCount = 0;
	let classifiedUsersAutoCount = 0;
	let classifiedUsersManualCount = 0;
	let classifiedUsersKeywordMismatch = 0;
	let classifiedUsersKeywordMatch = 0;
	let matchRate = 0;
	let currentChalk = chalk.black;

	const cursor = User.find(query).cursor({ batchSize: batchSizeParam });

	cursor.on("end", function() {
		console.log("convertClassifiedUsersCursor: END");
	});

	cursor.on("error", function(err) {
		console.error(chalkError("*** ERROR convertClassifiedUsersCursor: " + err));
		return callback(err, null);
	});

	cursor.on("close", function() {
		console.log("convertClassifiedUsersCursor: CLOSE");
	});

 	cursor.eachAsync(function(user){

		if (!user || !user.nodeId || (user.nodeId === undefined)) { // possilby protected twitter user account if nodeId === null
			console.log(chalkError("*** userServerController: ERROR: USER ID UNDEFINED\nparams" + jsonPrint(params)));
			console.log(chalkError("*** userServerController: ERROR: USER ID UNDEFINED\nuser" + jsonPrint(user)));
			// cursor.next();
			return;
		}

		classifiedUsersCount += 1;
		classifiedUsersManualCount += 1;

		const classificationManual = Object.keys(user.keywords)[0];
		let classificationAuto = false;

		if ((user.keywordsAuto !== undefined) && Object.keys(user.keywordsAuto).length > 0) {
			classificationAuto = Object.keys(user.keywordsAuto)[0];
		}

		user.category = classificationManual;

		if (classificationAuto) {
			classifiedUsersAutoCount += 1;
			user.categoryAuto = classificationAuto;
		}

		if (classificationManual && classificationAuto) {
			if (classificationManual === classificationAuto) {
				classifiedUsersKeywordMatch += 1;
				currentChalk = chalk.green;
			}
			else {
				classifiedUsersKeywordMismatch += 1;
				currentChalk = chalk.red;
			}
		}
		else {
			currentChalk = chalk.gray;
		}

		matchRate = 100 * classifiedUsersKeywordMatch/(classifiedUsersKeywordMatch+classifiedUsersKeywordMismatch);

    if (params.verbose) {
			console.log(currentChalk("CLU"
				+ " [ T:" + classifiedUsersCount
				+ " M:" + classifiedUsersManualCount
				+ " A:" + classifiedUsersAutoCount
				+ " +:" + classifiedUsersKeywordMatch
				+ " X:" + classifiedUsersKeywordMismatch + "]"
				+ " | MATCH: " + matchRate.toFixed(1) + "%"
				+ " | C: " + user.category
				+ " | CA: " + user.categoryAuto
				+ " | @" + user.screenName
				+ " | " + user.nodeId
				+ " | 3CF: " + user.threeceeFollowing
			));
    }

		classifiedUsersObj[user.nodeId.toString()] = classificationManual;

  	UserServerController.prototype.findOneUser(user, { noInc: true}, function(err, updatedUser){
  	});
	})
	.then(function(){

		debug(chalkInfo("convertClassifiedUsersCursor END"));

		callback(
			null, 
			{
				obj: classifiedUsersObj, 
				count: classifiedUsersCount, 
				matchRate: matchRate, 
				manual: classifiedUsersManualCount, 
				auto: classifiedUsersAutoCount
			}
		);
		
	})
	.catch(function(err){
		console.error(chalkError("*** ERROR findClassifiedUsersCursor: " + err));
		callback(err, null);
	});
};

UserServerController.prototype.findCategorizedUsersCursor = function (params, callback) {

	debug(chalkInfo("findCategorizedUsersCursor"
		+ "\nPARAMS: " + jsonPrint(params)
	));

	if (!User) {
		return(callback("MONGO User NOT DEFINED", null));
	}


	User.countDocuments({}, function(err, count){
		totalUsers = count;
		// console.log(chalkInfo("USC | " + totalUsers + " USERS IN DB"));
	});

	const startTimeStamp = moment().valueOf();
	let errorTimeStamp = startTimeStamp;

	const batchSizeParam = (params.batchSize !== undefined) ? params.batchSize : DEFAULT_CURSOR_BATCH_SIZE;
	const skipParam = (params.skip !== undefined) ? params.skip : false;
	const limitParam = (params.limit !== undefined) ? params.limit : false;
	const sortParam = (params.sort !== undefined) ? params.sort : {"nodeId" : 1};

	const query = (params.query) ? params.query : { "$or": [ { "category": { $nin: [ false, null ] } } , { "categoryAuto": { $nin: [ false, null ] } } ] };

	const defaultProjection = "nodeId screenName name description category categoryAuto mentions friendsCount followersCount statusesCount following threeceeFollowing";

	const projection = (params.projection) ? (params.projection) : defaultProjection;

	let categorizedUsersObj = {};
	let categorizedUsersCount = 0;
	let categorizedUsersAutoCount = 0;
	let categorizedUsersManualCount = 0;
	let categorizedUsersCategoryMismatch = 0;
	let categorizedUsersCategoryMatch = 0;
	let matchRate = 0;

	let currentChalk = chalk.black;

	let cursor = null;

	if (limitParam) {
		if (skipParam) {
			cursor = User
				.find(query)
				.lean()
				.select(projection)
				.sort(sortParam)
				.skip(skipParam)
				.limit(limitParam)
				.cursor();
		}
		else {
			cursor = User
				.find(query)
				.lean()
				.select(projection)
				.sort(sortParam)
				.limit(limitParam)
				.cursor();
		}
	}
	else {
		if (skipParam) {
			cursor = User
				.find(query)
				.lean()
				.select(projection)
				.sort(sortParam)
				.skip(skipParam)
				.cursor();
		}
		else {
			cursor = User
				.find(query)
				.lean()
				.select(projection)
				.sort(sortParam)
				.cursor();
		}
	}

	cursor.on("end", function() {
		console.log("findCategorizedUsersCursor: END");
	});

	cursor.on("error", function(err) {
		console.log(chalkError("*** ERROR findCategorizedUsersCursor: cursor on error: " + err));
	});

	cursor.on("close", function() {
		console.log("findCategorizedUsersCursor: CLOSE");
	});

 	cursor.eachAsync(function(user){

		if (!user || !user.nodeId || (user.nodeId === undefined)) { // possilby protected twitter user account if nodeId === null
			console.log(chalkError("*** userServerController: ERROR: USER ID UNDEFINED\nparams" + jsonPrint(params)));
			console.log(chalkError("*** userServerController: ERROR: USER ID UNDEFINED\nuser" + jsonPrint(user)));
		}

		categorizedUsersCount += 1;

		if (user.category) {
			categorizedUsersManualCount += 1;
		}

		if (user.categoryAuto) {
			categorizedUsersAutoCount += 1;
		}

		if (user.category && user.categoryAuto) {
			if (user.category === user.categoryAuto) {
				categorizedUsersCategoryMatch += 1;
				currentChalk = chalk.green;
			}
			else {
				categorizedUsersCategoryMismatch += 1;
				currentChalk = chalk.red;
			}
		}
		else {
			currentChalk = chalk.gray;
		}

		if (categorizedUsersCategoryMatch && categorizedUsersCategoryMismatch) {
			matchRate = categorizedUsersCategoryMatch/(categorizedUsersCategoryMatch+categorizedUsersCategoryMismatch) * 100;
		}

    if (params.verbose) {
			console.log(currentChalk("CL USR"
				+ " [ T:" + categorizedUsersCount
				+ " M:" + categorizedUsersManualCount
				+ " A:" + categorizedUsersAutoCount
				+ " +:" + categorizedUsersCategoryMatch
				+ " X:" + categorizedUsersCategoryMismatch + "]"
				+ " | MATCH: " + matchRate.toFixed(1) + "%"
				+ " | C: " + user.category
				+ " | CA: " + user.categoryAuto
				+ " | Ms: " + user.mentions
				+ " | @" + user.screenName
				+ " | " + user.nodeId
				+ " | 3CF: " + user.threeceeFollowing
			));
    }

		categorizedUsersObj[user.nodeId.toString()] = { 
			manual: user.category, 
			auto: user.categoryAuto,
			threeceeFollowing: user.threeceeFollowing
		};
	})
	.then(function(){

		debug(chalkInfo("findCategorizedUsersCursor END"));

		if (categorizedUsersCount === 0) {
			return callback(null, null);
		}

		callback(
			null, 
			{
				totalUsers: totalUsers,
				obj: categorizedUsersObj, 
				count: categorizedUsersCount, 
				matchRate: matchRate, 
				matched: categorizedUsersCategoryMatch, 
				mismatched: categorizedUsersCategoryMismatch, 
				manual: categorizedUsersManualCount, 
				auto: categorizedUsersAutoCount
			}
		);
	})
	.catch(function(err){
		errorTimeStamp = moment().valueOf();
		console.log(chalkError("*** ERROR findCategorizedUsersCursor: catch error: " + err));
		console.log(chalkError("findCategorizedUsersCursor CURSOR"
			+ " | START: " + moment(startTimeStamp).format(compactDateTimeFormat) 
			+ " | ERROR: " + moment(errorTimeStamp).format(compactDateTimeFormat)
			+ " | ELAPSED: " + msToTime(errorTimeStamp - startTimeStamp)
		));
		callback(err, null);
	});
};

UserServerController.prototype.convertRawUser = function (params, callback) {

	if (params.user === undefined) {
		console.error(chalkError("*** ERROR convertRawUser: UNDEFINED USER ID"
			+ "\n" + jsonPrint(params)
		));
		return(callback("UNDEFINED USER", params));
	}

	if ((params.user === undefined) || (params.user.id_str === undefined) || !params.user.id_str) {
		console.error(chalkError("*** ERROR convertRawUser: UNDEFINED USER ID"
			+ "\n" + jsonPrint(params.user)
		));
		return(callback("UNDEFINED USER ID", params.user));
	}

	let user = new User();

	user.isTwitterUser = true;
	user.nodeType = "user";
	user.nodeId = params.user.id_str;
	user.userId = params.user.id_str;
	user.name = params.user.name;
	user.previousName = params.user.name;
	user.screenName = params.user.screen_name.toLowerCase();
	user.screenNameLower = params.user.screen_name.toLowerCase();
	user.url = params.user.url;
	user.profileUrl = "http://twitter.com/" + params.user.screen_name;
	user.profileImageUrl = params.user.profile_image_url;
	user.bannerImageAnalyzed = params.user.profile_banner_url;
	user.bannerImageUrl = params.user.profile_banner_url;
	user.verified = params.user.verified;
	user.following = params.user.following;
	user.threeceeFollowing = params.user.threeceeFollowing;
	user.description = params.user.description;
	user.previousDescription = params.user.description;

	if (params.user.created_at && (params.user.created_at !== undefined)) { 
		user.createdAt = new Date(moment(params.user.created_at, twitterDateFormat, false).toISOString());
	}
	else {
		user.createdAt = new Date(moment().toISOString());
	}

	if (params.user.lastSeen && params.user.updateLastSeen) { 
		user.lastSeen = new Date(moment(params.user.lastSeen).toISOString());
	}
	else if (params.user.updateLastSeen) { 
		user.lastSeen = new Date(moment().toISOString());
	}
	
  user.lastTweetId = (params.lastTweetId) ? params.lastTweetId : false;
	user.mentions = 0;
	user.statusesCount = params.user.statuses_count || 0;
	user.friendsCount = params.user.friends_count || 0;
	user.followersCount = params.user.followers_count || 0;
	user.status = params.user.status || "";
	user.statusId = params.user.statusId || "0";
	
	if (params.user.status !== undefined) { user.status = params.user.status; }
	if (params.user.statusId !== undefined) { user.statusId = params.user.statusId; }
	if (params.user.previousStatusId !== undefined) { user.previousStatusId = params.user.previousStatusId; }

	user.category = (params.user.category) ? params.user.category : false;
	user.categoryAuto = (params.user.categoryAuto) ? params.user.categoryAuto : false;

	callback(null, user);
};

UserServerController.prototype.findOne = function (params, callback) {

	let searchParam = {};
	let sortParam = {"nodeId": 1};
	let skipValue = (params.skipValue === undefined) ? 0 : params.skipValue;
	let limit = (params.limit === undefined) ? 1 : params.limit;

	if (params.nodeSearchType) {
		switch (params.nodeSearchType) {
			case "USER_SPECIFIC":
				if (params.user.nodeId !== undefined) {
					searchParam.nodeId = params.user.nodeId;
					skipValue = 0;
				}
				else if (params.user.screenName !== undefined) {
					searchParam.screenName = params.user.screenName;
					skipValue = 0;
				}
				else {
					return(callback("USER_SPECIFIC UNDEFINED nodeId & screenName", params));
				}
			break;
			case "USER_UNCATEGORIZED":
				if ((params.nodeSearchBy !== undefined) && (params.nodeSearchBy === "createdAt")) {
					const searchDate = new Date(params.user.createdAt);
					sortParam = {"createdAt": -1};
					searchParam = { 
						"$and": [
							{createdAt: { "$lt": searchDate }},
							{category: { "$in": [ false, "false", null ] }}
						]
					};
					if (params.user.following) { searchParam["$and"].push({following: params.user.following}); }
					console.log(chalkInfo("FIND ONE | SEARCH BY CREATED AT"
						+ " | CR: " + moment(params.user.createdAt).format(compactDateTimeFormat)
						// + "\n" + jsonPrint(searchParam)
					));
				}
				else if ((params.nodeSearchBy !== undefined) && (params.nodeSearchBy === "lastSeen")) {

					const searchDate = new Date(params.user.lastSeen);

					sortParam = {"lastSeen": -1};
					searchParam = { 
						"$and": [
							{lastSeen: { "$lt": searchDate }},
							{category: { "$in": [ false, "false", null ] }}
						]
					};
					if (params.user.following) { searchParam["$and"].push({following: params.user.following}); }
					console.log(chalkInfo("FIND ONE | SEARCH BY LAST SEEN"
						+ " | CR: " + moment(params.user.lastSeen).format(compactDateTimeFormat)
						// + "\n" + jsonPrint(searchParam)
					));
				}
				else {
					sortParam = {"nodeId": 1};
					searchParam = { 
						"$and": [
							{nodeId: { "$gt": params.user.nodeId}},
							{category: { "$in": [ false, "false", null ] }}
						]
					};
				}
			break;
			case "USER_MISMATCHED":
				sortParam = {"nodeId": 1};
				searchParam = {
					"$and": [
						{ nodeId: { "$gt": params.user.nodeId} },
						{ category: { "$in": [ "left", "right", "neutral" ] } },
						{ categoryAuto: { "$in": [ "left", "right", "neutral" ] } },
						{ "$or": [
								{ "$and": [ { category: "left" }, { categoryAuto: { "$ne": "left"} } ] },
								{ "$and": [ { category: "right" }, { categoryAuto: { "$ne": "right"} } ] },
								{ "$and": [ { category: "neutral" }, { categoryAuto: { "$ne": "neutral"} } ] }
							]
						}
					]
				};
			break;
			default:
				sortParam = {"nodeId": 1};
				searchParam = params.user;
		}
	}
	else {
		sortParam = {"nodeId": 1};
		searchParam = params.user;
	}

	if (params.verbose) {
		console.log(chalkInfo("USC | findOne"
			+ "\nskipValue: " + skipValue
			+ "\nlimit:     " + limit
			+ "\nparams\n" + jsonPrint(params)
			+ "\nsearchParam\n" + jsonPrint(searchParam)
			+ "\nsortParam\n" + jsonPrint(sortParam)
		));
	}

	User
	.find(searchParam)
	.sort(sortParam)
	.select(params.fields)
	.skip(skipValue)
	.limit(limit)
	.lean()
	.exec(function(err, userArray) {

		if (err){
			console.error(chalkError("*** findOne USER FIND ONE ERROR: " + err));
			return(callback(err, null));
		}

		if (userArray.length > 0) {
			if (limit === 1) { 
				callback(null, userArray[0]);
			}
			else {
				callback(null, userArray);
			}
		}
		else {
	  	callback(null, null);
		}
	});
};

UserServerController.prototype.updateHistograms = function (params, callback) {

	const computeMaxInputsFlag = params.computeMaxInputsFlag || false;

	User.findOne({ nodeId: params.user.nodeId }).exec(function(err, user) {

		if (err){
			console.error(chalkError("*** updateHistograms USER FIND ONE ERROR: " + err));
			return(callback(err, null));
		}

		if (user) {

			debug("updateHistograms"
				+ " | FOUND USER: @" + user.screenName
				+ " | " + user.nodeId
			);

      if (!user.histograms || (user.histograms === undefined)) {
      	user.histograms = {};
      }

    	DEFAULT_INPUT_TYPES.forEach(function(type){
    		if (params.histograms[type] === undefined) { params.histograms[type] = {}; }
    		if (user.histograms[type] === undefined) { user.histograms[type] = {}; }
    		if (computeMaxInputsFlag && (maxInputsHashMap[type] === undefined)) { maxInputsHashMap[type] = {}; }
    	});

     	const paramsHistogramTypes = Object.keys(params.histograms);

      async.each(paramsHistogramTypes, function(type, cb0){

      	if (user.histograms[type] === undefined) { user.histograms[type] = {}; }
  	    if (computeMaxInputsFlag && (maxInputsHashMap[type] === undefined)) { maxInputsHashMap[type] = {}; }

      	const paramsHistogramTypeItems = Object.keys(params.histograms[type]);

      	debug(chalkInfo("USC | @" + user.screenName 
      		+ " | " + type 
      		+ " | NUM: " + paramsHistogramTypeItems.length
      	));

	      async.each(paramsHistogramTypeItems, function(itemParam, cb1){

	      	if (user.histograms[type][itemParam] === undefined) {
	      		user.histograms[type][itemParam] = params.histograms[type][itemParam];
	      	}
	      	else if (params.accumulateFlag) {
	      		user.histograms[type][itemParam] += params.histograms[type][itemParam];
	      	}


	      	if (computeMaxInputsFlag) {
		        if (maxInputsHashMap[type][itemParam] === undefined) { 
		          maxInputsHashMap[type][itemParam] = user.histograms[type][itemParam]; 
		        }
		        else {
		          maxInputsHashMap[type][itemParam] = Math.max(maxInputsHashMap[type][itemParam], user.histograms[type][itemParam]);
		        }
		      }

	      	debug(chalkInfo("USC | @" + user.screenName 
	      		+ " | " + type 
	      		+ " | TOT: " + user.histograms[type][itemParam]
	      		+ " | IN: " + params.histograms[type][itemParam] 
	      		+ " | " + itemParam 
	      	));

	        async.setImmediate(function() { cb1(); });

	      }, function () {

	      	if (computeMaxInputsFlag) {
			     	const userHistogramTypeItems = Object.keys(user.histograms[type]);

			      async.each(userHistogramTypeItems, function(itemUser, cb2){

			        if (maxInputsHashMap[type][itemUser] === undefined) { 
			          maxInputsHashMap[type][itemUser] = user.histograms[type][itemUser]; 
			        }
			        else {
			          maxInputsHashMap[type][itemUser] = Math.max(maxInputsHashMap[type][itemUser], user.histograms[type][itemUser]);
			        }

			        async.setImmediate(function() {	cb2();});
			      }, function(){
			        async.setImmediate(function() {	cb0();});
			      });
			    }
			    else {
			    	cb0();
			    }

	      });

      }, function(){

      	if (user.rate === undefined) { user.rate = 0; }
      	if (params.user.createdAt) { user.createdAt = params.user.createdAt; }
      	if (params.user.following) { user.following = params.user.following; }
      	if (params.user.threeceeFollowing) { user.threeceeFollowing = params.user.threeceeFollowing; }
      	if (params.user.profileImageUrl) { user.profileImageUrl = params.user.profileImageUrl; }
      	if (params.user.bannerImageAnalyzed) { user.bannerImageAnalyzed = params.user.bannerImageAnalyzed; }
      	if (params.user.bannerImageUrl) { user.bannerImageUrl = params.user.bannerImageUrl; }
      	if (params.user.category) { user.category = params.user.category; }
      	if (params.user.categoryAuto) { user.categoryAuto = params.user.categoryAuto; }
      	if (params.user.lastSeen && params.user.updateLastSeen) { user.lastSeen = params.user.lastSeen; }
      	if (params.user.lastTweetId) { user.lastTweetId = params.user.lastTweetId; }

      	if (params.user.followersCount) { user.followersCount = params.user.followersCount; }
      	if (params.user.friendsCount) { user.friendsCount = params.user.friendsCount; }
      	if (params.user.statusesCount) { user.statusesCount = params.user.statusesCount; }

	    	user.save(function(err, updatedUser){
	    		if (err) {
	    			console.log(chalkError("*** ERROR | updateHistograms user.save | " + err));
	    		}
	    		callback(err, updatedUser);
	    	});
      	
      });
		}
		else {

			debug("updateHistograms"
				+ " | MISS USER: @" + params.user.screenName
			);

			if (!params.histograms || (params.histograms === undefined)) { params.histograms = {}; }
			if (!params.user.histograms || (params.user.histograms === undefined)) { params.user.histograms = {}; }

    	DEFAULT_INPUT_TYPES.forEach(function(type){
    		if (params.histograms[type] === undefined) { params.histograms[type] = {}; }
    		if (params.user.histograms[type] === undefined) { params.user.histograms[type] = {}; }
    		if (maxInputsHashMap[type] === undefined) { maxInputsHashMap[type] = {}; }
    	});

      params.user.histograms = params.histograms;
      
    	UserServerController.prototype.findOneUser(params.user, {noInc: true}, function(err, updatedUser){

				debug("updateHistograms"
					+ " | UPDATED DB MISS USER: @" + updatedUser.screenName
				);

    		callback(err, updatedUser);
    	});
		}
	});
};

UserServerController.prototype.updateCategory = function (params, callback) {

	const newCategory = params.category || false;
	const newCategoryAuto = params.categoryAuto || false;

	User.findOne({ nodeId: params.user.nodeId }).exec(function(err, user) {

		if (err){
			console.error(chalkError("*** updateCategory USER FIND ONE ERROR: " + err));
			return(callback(err, null));
		}

		if (user) {

			console.log("updateCategory | FOUND USER IN DB ... UPDATING CATEGORY"
				+ " | CM: " + printCat(user.category)
				+ " | CA:" + printCat(user.categoryAuto)
				+ " | @" + user.screenName
				+ " | " + user.name
				+ " | " + user.nodeId
			);

    	if (newCategory) { user.category = newCategory; }
    	if (newCategoryAuto) { user.categoryAuto = newCategoryAuto; }

    	if (user.rate === undefined) { user.rate = 0; }
    	if (params.user.createdAt) { user.createdAt = params.user.createdAt; }
    	if (params.user.following) { user.following = params.user.following; }
    	if (params.user.threeceeFollowing) { user.threeceeFollowing = params.user.threeceeFollowing; }
    	if (params.user.profileImageUrl) { user.profileImageUrl = params.user.profileImageUrl; }
    	if (params.user.bannerImageAnalyzed) { user.bannerImageAnalyzed = params.user.bannerImageAnalyzed; }
    	if (params.user.bannerImageUrl) { user.bannerImageUrl = params.user.bannerImageUrl; }
    	if (params.user.lastSeen && params.user.updateLastSeen) { user.lastSeen = params.user.lastSeen; }
    	if (params.user.lastTweetId) { user.lastTweetId = params.user.lastTweetId; }

    	if (params.user.followersCount) { user.followersCount = params.user.followersCount; }
    	if (params.user.friendsCount) { user.friendsCount = params.user.friendsCount; }
    	if (params.user.statusesCount) { user.statusesCount = params.user.statusesCount; }

    	user.save(function(err, updatedUser){
				console.log("updateCategory"
					+ " | UPDATED DB HIT USER"
					+ " | CM: " + printCat(updatedUser.category)
					+ " | CA:" + printCat(updatedUser.categoryAuto)
					+ " | @" + updatedUser.screenName
					+ " | " + updatedUser.name
					+ " | " + updatedUser.nodeId
				);

    		callback(err, updatedUser);
    	});
		}
		else {

			console.log("updateCategory"
				+ " | MISS USER: @" + params.user.screenName
			);

    	if (newCategory) { params.user.category = newCategory; }

    	UserServerController.prototype.findOneUser(params.user, {noInc: true}, function(err, updatedUser){

				console.log("updateCategory"
					+ " | UPDATED DB MISS USER: @" + updatedUser.screenName
					+ " | CAT: M: " + updatedUser.category + " | A: " + updatedUser.categoryAuto
				);

    		callback(err, updatedUser);
    	});
		}
	});
};

module.exports = UserServerController;
